#!/bin/bash

info() {
  echo "info: $1" | tee -a /tmp/run.bis
}

error() {
  echo "error: $1" | tee -a /tmp/run.bis
}

run() {
  eval "$1" >> /tmp/run.bis 2>&1
}

do_test() {
  SKIPPED=0

  info "commit: $(git rev-parse HEAD)"
  info "reconfiguring..."

  if [[ -f 'autogen.sh' ]]; then
    run "./autogen.sh"
  elif [[ -f 'configure.ac' ]]; then
    run "autoreconf -vfi"
  elif [[ ! -f 'configure' ]]; then
    error "how do I configure?"
    git reset --hard > /dev/null 2>&1
    git bisect skip
    SKIPPED=1
  fi

  info "configuring..."

  run "./configure CFLAGS=\"-fsanitize=address -g\" \
    CXXFLAGS=\"-fsanitize=address -g\" \
    LDFLAGS=\"-fsanitize=address -g\""

  if [[ $? != 0 ]]; then
    error "configure failed?"
    git reset --hard > /dev/null 2>&1
    git bisect skip
    SKIPPED=1
  elif [[ ! -f 'Makefile' ]]; then
    error "no Makefile detected."
    git reset --hard > /dev/null 2>&1
    git bisect skip
    SKIPPED=1
  fi

  info "building..."

  run "make -j"

  if [[ $? != 0 ]]; then
    error "make failed."
    git reset --hard > /dev/null 2>&1
    git bisect skip
    SKIPPED=1
  fi

  info "running..."

  cp $POC .poc.input
  $CMD > /tmp/bisect_dump.bis 2>&1
}

test_bug() {
  if [[ -n $(grep $BUG_TYPE /tmp/bisect_dump.bis) ]] && \
    [[ -n $(grep $CRASH_FUNC /tmp/bisect_dump.bis) ]]; then
    info "bad"
    CODE=1
  else
    info "gud"
    CODE=0
  fi
}

cleanup_bisect() {
  rm -f bad.bis good.bis FIRSTBAD
}


# Initialize

rm -f /tmp/run.bis

if [[ -z $1 ]] && [[ -f BISECT ]]; then
  BISECT=$(cat BISECT)
  if [[ -z "$BISECT" ]]; then
    error "empty BISECT file"
    exit
  fi

  BAD_COMMIT=$(echo "$BISECT" | awk '{ print $1 }')
  GOOD_COMMIT=$(echo "$BISECT" | awk '{ print $2 }')
  POC=$(echo "$BISECT" | awk '{ print $3 }')
  CMD=$(cat BISECT | tail -1 | cut -d' ' -f5-)
  CMD=$(echo "$CMD" | sed 's/@@/.poc.input/g')
else
  error "usage: $0"
  error "usage: (read argument through the BISECT file)"
  exit
fi

if [[ -z "$CMD" ]]; then
  error "no command"
  exit
fi


info "'$BAD_COMMIT' to '$GOOD_COMMIT'..."
info "poc input: $POC"
info "poc command: $CMD"


# Initial ASAN dump

info "generating the most recent ASAN dump..."


git checkout $BAD_COMMIT --force

if [[ $? != 0 ]]; then
  error "cannot checkout the bad commit."
  exit
fi


do_test

if [[ -z "grep AddressSanitizer /tmp/bisect_dump.bis" ]] && \
  [[ -z "grep Assertion /tmp/bisect_dump.bis" ]]; then
  error "bad commit ($BAD_COMMIT) is not bad."
  exit
fi


# Extract: bug type, crashing function name

while read LINE; do
  if [[ -n $(echo $LINE | grep Assertion) ]]; then
    BUG_TYPE=Assertion

    for WORD in $LINE; do
      if [[ $WORD == "Assertion" ]]; then
        break
      else
        CRASH_FUNC=${WORD%:}
      fi
    done
  elif [[ -n $(echo $LINE | grep AddressSanitizer) ]]; then
    BUG_TYPE=

    if [[ $(echo $LINE | grep SEGV) ]]; then
      BUG_TYPE=SEGV
    elif [[ $(echo $LINE | grep SIGFPE) ]]; then
      BUG_TYPE=SIGFPE
    else
      for WORD in $LINE; do
        if [[ $WORD == "on" ]]; then
          break
        else
          BUG_TYPE=$WORD
        fi
      done
    fi

    if [[ -z "$BUG_TYPE" ]]; then
      error "no bug type detected."
      exit
    fi

    _BT_DET=1
  elif [[ $_BT_DET == "1" ]]; then
    HEAD=$(echo $LINE | awk '{ print $1 }')
    if [[ ${HEAD:0:1} == '#' ]]; then
      if [[ -z $(echo $LINE | grep 'asan') ]] && \
        [[ -z $(echo $LINE | grep 'sanitizer') ]] && \
        [[ -z $(echo $LINE | grep 'libc') ]]; then
        CRASH_FUNC=$(echo $LINE | awk '{ print $4 }')
        break
      fi
    fi
  fi
done < /tmp/bisect_dump.bis 


info "bug_type: $BUG_TYPE"
info "crash_func: $CRASH_FUNC"

if [[ -z "$BUG_TYPE" ]] || [[ -z "$CRASH_FUNC" ]]; then
  error "bug_type or crash_func not found."
  exit
fi

git reset --hard


# Begin bisect

git bisect start $BAD_COMMIT $GOOD_COMMIT

while true; do
  if [[ -n $(git bisect log | tail -1 | grep "first bad commit") ]]; then
    break
  fi

  do_test
  
  if [[ $SKIPPED == 1 ]]; then
    continue
  fi

  test_bug

  make clean > /dev/null 2>&1

  mv BISECT /tmp
  mv "$POC" /tmp
  rm -rf *
  git checkout .
  mv /tmp/BISECT .
  mv /tmp/"$POC" .

  if [[ $CODE == 0 ]]; then
    git bisect good
  else
    git bisect bad
  fi
done


git bisect reset bisect/bad 


# Verification

git reset --hard
do_test
cp /tmp/bisect_dump.bis bad.bis
echo $(git rev-parse HEAD) >> bad.bis
test_bug

if [[ $CODE != 1 ]]; then
  cleanup_bisect
  error "cannot find a bad commit."
  exit
fi

git reset --hard
git checkout HEAD~
do_test
cp /tmp/bisect_dump.bis good.bis
echo $(git rev-parse HEAD) >> good.bis
test_bug

if [[ $CODE != 0 ]]; then
  cleanup_bisect
  error "not a first bad commit."
  exit
fi


git reset --hard
git checkout HEAD@{1}

echo $(git rev-parse HEAD) > FIRSTBAD

info "first bad commit: $(git rev-parse HEAD)"
